/*
 *	Copyright (C) 2009 by Miltiadis Allamanis
 *
 *	Permission is hereby granted, free of charge, to any person obtaining a copy
 *	of this software and associated documentation files (the "Software"), to deal
 *	in the Software without restriction, including without limitation the rights
 *	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *	copies of the Software, and to permit persons to whom the Software is
 *	furnished to do so, subject to the following conditions:
 *
 *	The above copyright notice and this permission notice shall be included in
 *	all copies or substantial portions of the Software.
 *
 *	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *	THE SOFTWARE.
 */
#include "OrderProducer.h"

void OrderProducer::producerThread(Market *oMarket)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-13-1--72469725:1292cfe5a46:-8000:0000000000000DF3 begin
{
	myMarket = oMarket;
	incomingQueue = myMarket->incomingQueue;
	long count = 0;
	long sellExcess = 0;
	srand(0);
	int magnitude = 10;
	int waitmsec;

	while (true) {
		Order *ord = myMarket->allocOrder();
		//std::cout<<"Creating "<<ord<<"\n";

		// wait for a random amount of time in useconds
		waitmsec = ((double) rand() / (double) RAND_MAX * magnitude);
		usleep(waitmsec * 1000);

		ord->id = count++;
		ord->timestamp = myMarket->getTimestamp();

		// Buy or Sell
		ord->action = ((double) rand() / (double) RAND_MAX <= 0.5) ? 'B' : 'S';

		// Order type
		double u2 = ((double) rand() / (double) RAND_MAX);
		if (u2 < 0.2) {
			ord->type = 'M'; // Market order
			ord->vol = (1 + rand() % 50) * 100;
			if (ord->action == 'S')
				sellExcess -= ord->vol;
			else
				sellExcess += ord->vol;
			//std::cout<<sellExcess<<"\n";
		} else if (0.2 <= u2 && u2 < 0.4) {
			ord->type = 'L'; // Limit order
			ord->vol = (1 + rand() % 50) * 100;
			ord->price1 = myMarket->currentPrice.getPrice() + 10 * (0.5
					- ((double) rand() / (double) RAND_MAX));

		} else if (0.4 <= u2 && u2 < 0.6) {
			ord->type = 'S'; // Stop order
			ord->vol = (1 + rand() % 50) * 100;
			ord->price1 = myMarket->currentPrice.getPrice() + 10 * (0.5
					- ((double) rand() / (double) RAND_MAX));

		} else if (0.6 <= u2 && u2 < 0.8) {
			ord->type = 'T'; // Stop Limit order
			ord->vol = (1 + rand() % 50) * 100;
			ord->price2 = myMarket->currentPrice.getPrice() + 10 * (0.5
					- ((double) rand() / (double) RAND_MAX));
			ord->price1 = myMarket->currentPrice.getPrice() + 10 * (0.5
					- ((double) rand() / (double) RAND_MAX));

		} else if (0.8 <= u2) {
			ord->type = 'C'; // Cancel order
			ord->id = ((double) rand() / (double) RAND_MAX) * count;
			ord->vol = 1;
		}
		//ord->display();
		//Push to incoming queue
		ord->status = STATUS_INCOMING;
		incomingQueue->addOrder(ord);
	}
}
// section -64--88-13-1--72469725:1292cfe5a46:-8000:0000000000000DF3 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

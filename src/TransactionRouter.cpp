/*
 *	Copyright (C) 2009 by Miltiadis Allamanis
 *
 *	Permission is hereby granted, free of charge, to any person obtaining a copy
 *	of this software and associated documentation files (the "Software"), to deal
 *	in the Software without restriction, including without limitation the rights
 *	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *	copies of the Software, and to permit persons to whom the Software is
 *	furnished to do so, subject to the following conditions:
 *
 *	The above copyright notice and this permission notice shall be included in
 *	all copies or substantial portions of the Software.
 *
 *	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *	THE SOFTWARE.
 */
#include "TransactionRouter.h"

/**
 *  This object contains the threads that are responsible for routing incoming threads to the corresponding queues and heaps
 */

void TransactionRouter::routerThread(Market *oMarket)
// section -64--88-13-1--72469725:1292cfe5a46:-8000:0000000000000EB4 begin
{
	incomingQueue = (OrderList *) oMarket->incomingQueue;
	activeQueue = (OrderList *) oMarket->activeQueue;
	marketBuyList = (OrderList *) oMarket->marketBuyList;
	marketSellList = (OrderList *) oMarket->marketSellList;
	buyLimitList = (OrderList *) oMarket->buyLimitList;
	sellLimitList = (OrderList *) oMarket->sellLimitList;
	sellStopList = (OrderList *) oMarket->sellStopList;
	buyStopList = (OrderList *) oMarket->buyStopList;
	while (true) {
		incomingQueue->waitNotEmpty();
		Order *ord = 0;
		ord = incomingQueue->peek(0, true);
		assert(ord!=0);
		switch (ord->type) {
		case 'M':
			if (ord->vol == 0) {
				oMarket->deleteOrder(ord);
				continue;
			}
			if (ord->isBuy()) {
				marketBuyList->addOrder(ord);
				//std::cout<<"Added to buy:";ord->display();
			} else {
				marketSellList->addOrder(ord);
				//std::cout<<"Added to sell:";ord->display();
			}
			activeQueue->addOrder(ord);
			//std::cout<<"Added to active:";ord->display();
			//ord->display();
			break;
		case 'L':
			if (ord->vol == 0) {
				oMarket->deleteOrder(ord);
				continue;
			}
			if (ord->isBuy()) {
				buyLimitList->addOrder(ord);
			} else {
				sellLimitList->addOrder(ord);
			}
			activeQueue->addOrder(ord);
			break;
		case 'S':
		case 'T':
			if (ord->vol == 0) {
				oMarket->deleteOrder(ord);
				continue;
			}
			if (ord->isBuy()) {
				buyStopList->addOrder(ord);
			} else {
				sellStopList->addOrder(ord);
			}

			break;
		case 'C':
			pthread_t cancelThreadId;
			cancelArg *args;
			args = new cancelArg;
			args->oMarket = oMarket;
			args->id = ord->id;
			pthread_create(&cancelThreadId, NULL, Market::startCancelThread,
					args);
			pthread_detach(cancelThreadId);
		default:
			//std::cout<<"Deleting "<<ord<<" (non-market)\n";
			oMarket->deleteOrder(ord);
			break;
		}

	}
}
// section -64--88-13-1--72469725:1292cfe5a46:-8000:0000000000000EB4 end


void TransactionRouter::cancelThread(int orderId)
// section -64--88-13-1--72469725:1292cfe5a46:-8000:0000000000000EEB begin
{
	if (incomingQueue->cancelOrder(orderId))
		return;
	else if (buyStopList->cancelOrder(orderId))
		return;
	else if (sellStopList->cancelOrder(orderId))
		return;
	else if (activeQueue->cancelOrder(orderId))
		return;
}
// section -64--88-13-1--72469725:1292cfe5a46:-8000:0000000000000EEB end


/** 
 *  adds a stop order to the corresponding heaps
 */
void TransactionRouter::addStopOrder(Order *oOrder)

// section -64--88-13-1-4137f8f2:129306551b9:-8000:000000000000125D begin
{
}
// section -64--88-13-1-4137f8f2:129306551b9:-8000:000000000000125D end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element


/** 
 *  converts a stop order (given as an arg) to a corresponding (market or limit) order. It then pushes the order at the end of the active linked list and to the corresponding heaps
 */
void TransactionRouter::convertStopOrder(Order *oOrder)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-13-1-4137f8f2:129306551b9:-8000:0000000000001261 begin
{
}
// section -64--88-13-1-4137f8f2:129306551b9:-8000:0000000000001261 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element


/** 
 *  adds an active Market order to the corresponding queue
 */
void TransactionRouter::addMarketOrder(Order *oOrder)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-13-1-4137f8f2:129306551b9:-8000:0000000000001265 begin
{
}
// section -64--88-13-1-4137f8f2:129306551b9:-8000:0000000000001265 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element


/** 
 *  add a limit order at the corresponding heap
 */
void TransactionRouter::addLimitOrder(Order *oOrder)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-13-1-4137f8f2:129306551b9:-8000:0000000000001268 begin
{
}
// section -64--88-13-1-4137f8f2:129306551b9:-8000:0000000000001268 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element
